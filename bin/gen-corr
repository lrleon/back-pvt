#!/usr/bin/env ruby
# -*- coding: iso-8859-1 -*-

require 'fileutils'
require 'optparse'
require 'calculus.rb'

pvt = ENV['PVT']

load "#{pvt}/include/correlations/symbols"

class CorrelationGen

  class Parameter

    attr_reader :name, :desc, :unit, :min, :max

    def initialize(name, unit, desc, min = nil, max = nil)
      @name = name
      @desc = desc
      @unit = unit
      @min = min
      @max = max
    end

    def make
      s = "add_parameter(\"#{@name}\", #{@unit}::get_instance(), \"#{@desc}\""
      s += ", #{@min}" if @min
      s += ", #{@max}" if @max
      s += ");\n"
      s += "def_parameter_latex_symbol(\"#{@name}\", \"#{$par_symbols[@name]}\");\n" if $par_symbols[@name]
      s
    end
  end

  def initialize(name, unit, min = nil, max = nil)
    fail "correlation subtype has not been defined" unless $subtype
    @name = name
    @author = "Not defined"
    @subtype = $subtype.subtype_name
    @unit = unit
    @min = min
    @max = max
    @pars = []
    @db = []
    @notes = []
    @internal_notes = []
    @refs = []
    @synonyms = []
    @eq = []
    @vars = []
  end

  attr_reader :name

  def set_hidden
    @hidden = true;
  end

  def set_hidden_calc
    @hidden_calc = true;
  end

  def set_hidden_blackoil_grid
    @hidden_blackoil_grid = true;
  end

  def set_hidden_wetgas_grid
    @hidden_wetgas_grid = true;
  end

  def set_hidden_drygas_grid
    @hidden_drygas_grid = true;
  end

  def add_doc(str)
    @doc = str
  end

  def add_title(title)
    @title = title
  end

  def add_author(name)
    @author = name
  end

  def add_db(db)
    @db << db
  end

  def add_note(note)
    @notes << note
  end

  def add_internal_note(note)
    @internal_notes << note
  end

  def add_ref(tag)
    @refs << tag
  end

  def add_eq(eq)
    @eq << eq
  end

  def add_parameter(name, unit, desc, min = nil, max = nil)
    @pars << Parameter.new(name, unit, desc, min, max)
    @latex_symbol = $par_symbols[name]
    $pars_set.add name
    $subtype.def_parameter name, unit
  end

  def add_synonym(par_name, syn_name, unit_name)
    @synonyms << [par_name, syn_name, unit_name]
    $subtype.def_synonym syn_name, par_name, unit_name
  end

  def add_variable(name, type)
    @vars << [name, type]
  end

  def add_precondition(*pnames)
    fail "precondition check has already been defined" if @pnames
    if !pnames.all? { |name| @pars.detect { |par| par.name == name } }
      fail "Any parameter between #{pnames} was not defined"
    end
    @pnames = pnames
  end

  def impl_type() "Quantity<#{@unit}>" end

  def gen_pars
    s = ''
    @pars.each do |par|
      s += "const Quantity<#{par.unit}> & #{par.name}"
      s += ",\n" unless par == @pars.last
    end
    s
  end

  def gen_doubles
    s = "("
    @pars.each do |par|
      s += "const double & #{par.name}"
      s += ",\n" unless par == @pars.last
    end
    s += ")"
  end

  def gen_impl_declaration
    s = "static inline double impl"
    s += gen_doubles + 'noexcept'
  end

  def gen_call_declaration
    s = "#{impl_type} call(#{gen_pars}) const\n"\
        "{\n"
    s += "     precondition(#{@pnames.join(',')});\n" if @pnames
    s += "  return #{impl_type}(impl("
    @pars.each do |par|
      s += par.name + '.raw()'
      s += ', ' unless par == @pars.last
    end
    s += "));\n"\
         "}\n"
  end

  def gen_par_operator
    s = "#{impl_type} operator () (#{gen_pars}) const\n"\
        "{\n"
    s += "  return #{impl_type}(call("
    @pars.each do |par|
      s += par.name
      s += ', ' unless par == @pars.last
    end
    s += "));\n"\
         "}\n"
  end

  def gen_precondition_pars
    s = ''
    @pnames.each do |pname|
      par = @pars.detect { |par| par.name == pname }
      s += "const Quantity<#{par.unit}> & #{par.name}"
      s += ",\n" unless pname == @pnames.last
    end
    s
  end

  def gen_precondition_declaration
    "inline void precondition(\n"\
    "#{gen_precondition_pars}) const;\n"\
    "\n"
  end

  def pars_list
    s = ""
    @pars.each do |par|
      s += "#{par.name}"
      s += "," unless par == @pars.last
    end
    s
  end

  def gen_eq(dir = '.')
    fail "Correlation #{@name} has not defined an equation" unless @eq.empty?
    @eq.each_with_index do |eq, i|
      file_name = Calculus::Expression.new(eq, :parse => false).to_png      
      fail "Failed to generate eq for #{@name}" unless file_name
      tgt_name = "#{dir}/#{name}-#{i}.png"
      FileUtils.mv(file_name, tgt_name)
    end
  end

  def make_eq(dir = '.')
    return if @eq.empty?
    @eq.each_with_index do |eq, i|
      file_name = Calculus::Expression.new(eq, :parse => false).to_png
      fail "Failed to generate eq for #{@name}" unless file_name
      tgt_name = "#{dir}/#{name}-#{i}.png"
      FileUtils.mv(file_name, tgt_name)
      puts "Generated #{tgt_name}"
    end
  end

  def gen_pars_extraction()
    s = "    auto it = pars.get_it();\n"
    @pars.each do |par|
      s += "    const auto & #{par.name} = it.get_curr();"
      s += "    it.next();\n" unless par == @pars.last
    end
    s
  end

  def gen_call
    "return call(#{pars_list});\n"\
  end

  def gen_compute
    s = "virtual VtlQuantity compute(const DynList<VtlQuantity> & pars,\n"\
        "bool check = true) const\n"\
        "{\n"\
        "   if (check)\n"\
        "     verify_preconditions(pars);\n"\
        "\n"\
        "#{gen_pars_extraction}\n"\
        "\n"\
        "     #{gen_call}\n"\
        "}\n"\
        "\n"\
        "virtual VtlQuantity invoke(bool check = true) const\n"\
        "{\n"\
        " if (not check)\n"\
        "    return call(#{pars_list});\n"\
        "\n"
    @pars.each do |par|
      if par.name != 'p' && par.name != 't'
        s += "  if (not (#{par.name} >= #{par.min}))\n"\
             "    ZENTHROW(OutOfParameterRange, "\
             "\"parameter #{par.name} is less than #{par.min}\");\n" if par.min
        s += "  if (not (#{par.name} <= #{par.max}))\n"\
             "    ZENTHROW(OutOfParameterRange, "\
             "\"parameter #{par.name} is greater than #{par.max}\");\n" if par.max
      end
    end
    s += "\n"\
         "return call(#{pars_list});\n"\
         "}\n"\
         "\n"
  end

  def extern_sign
    "#{impl_type} #{@name}__correlation__fct(#{gen_pars})"
  end

  def extern_sign_doubles
    "double #{@name}__correlation__valid__fct #{gen_doubles}"
  end

  def gen_class
    s = "/** #{@name}\n\n"\
        "    Generated at #{Time.now}\n"\
        "\n"\
        "    Zen Technologies Group\n"
    s += @doc if @doc
    @internal_notes.each { |note| s += "#{note.ljust(60)}\n\n" }
    s += "\n"\
         "*/\n"
    s += "class #{@name} : public #{@subtype}\n" \
         "{\n"\
         "Correlation_Singleton(#{@name});\n"\
         "\n"\
         "#{@name}()\n"\
         "  : #{@subtype}(\"#{@name}\", #{@unit}::get_instance()"
    s += ", #{@min}" if @min
    s += ", #{@max}" if @max
    s += ")\n"\
         "{\n"
    s += "set_author(\"#{@author}\");"
    s += "set_title(\"#{@title}\");" if @title
    s += "set_hidden();" if @hidden
    s += "set_hidden_blackoil_grid();" if @hidden_blackoil_grid
    s += "set_hidden_wetgas_grid();" if @hidden_wetgas_grid
    s += "set_hidden_drygas_grid();" if @hidden_drygas_grid
    s += "set_hidden_calc();" if @hidden_calc
    @pars.each { |par| s += par.make }
    @db.each { |db| s += "add_db(\"#{db}\");\n" }
    @notes.each { |note| s += "add_note(\"#{note}\");\n" }
    @refs.each { |ref| s += "add_ref(\"#{ref}\");\n" }
    @synonyms.each do |syn|
      s += "add_par_synonym(\"#{syn[0]}\", \"#{syn[1]}\", \"#{syn[2]}\");\n"
    end
    #s += "add_latex_symbol("  \"#{par_symbols[@latex_symbol]}\""
    s += "}\n"\
         "\n"
    s += gen_precondition_declaration if @pnames
    s += "public:\n"\
         "\n"\
         "#{gen_impl_declaration};\n"\
         "\n"\
         "#{gen_call_declaration}\n"\
         "\n"\
         "#{gen_par_operator}\n"\
         "\n"
    s += gen_compute
    s += "};\n"\
         "\n"\
         "extern #{extern_sign};\n"\
         "extern #{extern_sign_doubles};\n"\
         "\n"
  end

  def gen_extern_calls
    s = "#{extern_sign}\n"\
        "{\n"\
        "  return #{@name}::get_instance()("
    @pars.each do |par|
      s += par.name
      s += ',' if par != @pars.last
    end
    s += ");\n"\
         "}\n"\
         "\n"\
         "#{extern_sign_doubles}\n"\
         "{\n"\
         "  return #{@name}::get_instance()("
    @pars.each do |par|
      s += par.name
      s += ',' if par != @pars.last
    end
    s += ").raw();\n"\
         "}\n"
  end

  def gen_impl
    s = "\n"\
        "double\n"\
        "#{@name}::impl#{gen_doubles} noexcept\n"\
        "{\n"\
        "    // put here the implementation\n"\
        "}\n"\
        "\n"
    return s unless @pnames
    s += "void #{@name}::precondition(#{gen_precondition_pars}) const\n"\
         "{\n"\
         "    // put here the implementation\n"\
         "}\n"
  end

  def gen
    gen_class + gen_impl
  end
end

require 'set'
require 'json'

$subtype = nil
$pars_set = Set.new
$corr_list = []
$curr_corr = nil

class CorrelationSubtype

  attr_reader :subtype_name, :type_name, :symbol, :synonyms

  def initialize(subtype_name, type_name, latex_symbol)
    @subtype_name = subtype_name
    @type_name = type_name
    @symbol = latex_symbol
    @pars = {}
    @synonyms = {}
    @methods
  end

  def def_parameter(par_name, unit_name)
    return if @pars.has_key? par_name
    @pars[par_name] = [unit_name, []]
  end

  def def_synonym(syn_name, par_name, unit_name)
    fail "ERROR in def of synonym #{syn_name}: parameter #{par_name} has not been defined" unless @pars.has_key? par_name
    return if @synonyms.has_key? syn_name
    @synonyms[syn_name] = [par_name, unit_name]
    @pars[par_name][1] << syn_name
  end

  def pars_declarations
    s = ''
    @pars.each do |name, p|
      unit = p[0]
      synonyms = p[1]
      s += "protected:\n"\
           "\n"\
           "Quantity<#{unit}> #{name};\n"\
           "\n"\
           "public:\n"\
           "\n"\
           "void set_#{name}(const Quantity<#{unit}> & #{name})\n"\
           "{\n"\
           "  this->#{name} = #{name};\n"
      synonyms.each do |syn_name|
        s += "  this->#{syn_name} = #{name};\n" if @pars.has_key? syn_name
      end
      if @synonyms.has_key? name
        par_name, syn_unit = @synonyms[name]
        s += "  this->#{par_name} = #{name};"
      end
      s += "}\n"\
           "\n"\
           "private:\n"\
           "\n"\
           "static void __set_#{name}(#{@subtype_name} * ptr, double val, const Unit & unit)\n"\
           "{\n"\
           "  ptr->set_#{name}(VtlQuantity(unit, val));\n"\
           "}\n"\
           "\n"
    end
    @synonyms.each do |syn_name, p|
      par_name = p[0]
      syn_unit = p[1]
      if !@pars.has_key? syn_name
        s += "void set_#{syn_name}(const Quantity<#{syn_unit}> & #{syn_name})\n"\
             "{\n"\
             "  #{par_name} = Quantity<#{syn_unit}>(#{syn_name});\n"\
             "}\n"
      end
    end
    s
  end

  def compute_methods
    methods = {}
    @pars.each do |name, p|
      unit, synonyms = p
      methods[name] = unit
    end
    @synonyms.each do |syn_name, p|
      _, syn_unit = p
      methods[syn_name] = syn_unit unless @pars.has_key? syn_name
    end
    methods
  end

  def gen_subtype_class
    names = Set.new(@pars.map { |name,_| name})    
    s = "class #{@subtype_name} : public #{@type_name}\n"\
        "{\n"\
        "public:\n"\
        "\n"\
        "const DynSetTree<string> names =\n"\
        "{\n"
    @synonyms.each do |syn_name, p|
      par_name = p[0]
      s += "\"#{syn_name}\",\n" unless names.include? syn_name
    end
    names.each_with_index do |name, i|
      s += "\"#{name}\""
      s += ",\n" if i < names.length - 1
    end
    s += "};\n"\
         "\n"\
         "bool has_name(const string & name) const { return names.has(name); }\n"\
         "\n"\
        "#{pars_declarations}\n"\
        "\n"\
        "public:\n"\
        "\n"\
        "void set_par(const string & name, double val, const Unit & unit)\n"\
        "{\n"\
        "  static AHDispatcher<string,\n"\
        "                      void (*)(#{@subtype_name}*, double, const Unit&)>\n"\
        "    dispatcher = \n"\
        "  {\n"
    @synonyms.each do |syn_name, p|
      par_name = p[0]
      if !@pars.has_key? syn_name
        s += "\"#{syn_name}\", __set_#{par_name},\n"
      end
    end
    @pars.each_with_index do |p, i|
      s += "\"#{p[0]}\", __set_#{p[0]}"
      s += ",\n" unless i == @pars.length - 1
    end
    s += "};\n"\
         "\n"\
         "  dispatcher.run(name, this, val, unit);\n"\
         "};\n"\
         "\n"\
         "  #{@subtype_name}(const string & name, const Unit & result_unit,\n"\
         "       double min_val, double max_val)\n"\
         "    : #{@type_name}(\"#{@subtype_name}\", name, \"#{@symbol}\",\n"\
         "        result_unit, min_val, max_val) {}\n"\
         "\n"\
         "  #{@subtype_name}(const string & name, const Unit & unit,\n"\
         "       double min_val)\n"\
         "    : #{@type_name}(\"#{@subtype_name}\", name, \"#{@symbol}\", unit,\n"\
         "      min_val, unit.max_val) {}\n"\
         "\n"\
         "  #{@subtype_name}(const string & name, const Unit & unit)\n"\
         "    : #{@type_name}(\"#{@subtype_name}\", name, \"#{@symbol}\", unit,\n"\
         "         unit.min_val, unit.max_val) {}\n"\
         "\n"\
         "virtual VtlQuantity invoke(bool check = true) const\n"\
         "{\n"\
         "  if (check or !check)\n"\
         "    ZENTHROW(WrongCall, "\
         "\"Invalid call to #{@subtype_name}::compute()\");\n"\
         "  return VtlQuantity::null_quantity;\n"\
         "}\n"\
         "\n"\
         "protected:\n"\
         "\n"\
         "using #{@type_name}::add_parameter;\n"\
         "}\n;"\
         "\n"
  end

  def gen_pars_set_class
    "struct #{@subtype_name}Pars\n"\
    "{\n"\
    "#{pars_declarations}\n"\
    "};\n"    
  end

  def to_json
    [compute_methods, @subtype_name].to_json
  end
end

def declare_correlation_subtype(subtype_name, type_name, latex_symbol)
  if $subtype
    fail "correlation subtype #{$subtype.subtype_name} has already been defined"
  end
  $subtype = CorrelationSubtype.new(subtype_name, type_name, latex_symbol)
end

def begin_correlation(name, unit, min = nil, max = nil)
  $curr_corr = CorrelationGen.new(name, unit, min, max)
end

def set_hidden
  $curr_corr.set_hidden
end

def set_hidden_blackoil_grid
  $curr_corr.set_hidden_blackoil_grid
end

def set_hidden_drygas_grid
  $curr_corr.set_hidden_blackoil_grid
end

def set_hidden_wetgas_grid
  $curr_corr.set_hidden_blackoil_grid
end

def set_hidden_calc
  $curr_corr.set_hidden_calc
end

def add_parameter(name, unit, desc, min = nil, max = nil)
  $curr_corr.add_parameter(name, unit, desc, min, max)
end

def add_synonym(par_name, syn_name, unit_name)
  $curr_corr.add_synonym(par_name, syn_name, unit_name)
end

def add_doc(str)
  $curr_corr.add_doc(str)
end

def add_precondition(*pnames)
  $curr_corr.add_precondition(*pnames)
end

def add_variable(name, type)
  $curr_corr.add_variable name, type
end

def add_title(title)
  $curr_corr.add_title(title)
end

def add_author(name)
  $curr_corr.add_author(name)
end

def add_eq(eq)
  $curr_corr.add_eq(eq)
end

def add_db(db)
  $curr_corr.add_db(db)
end

def add_note(note)
  $curr_corr.add_note(note)
end

def add_internal_note(note)
  $curr_corr.add_internal_note(note)
end

def add_hidden_note(note)
  $curr_corr.add_internal_note(note)
end

def add_eq(eq)
  $curr_corr.add_eq(eq)
end

def end_correlation
  $corr_list << $curr_corr
end

def gen_impl_declarations
  s = ""
  $corr_list.each do |corr|
    s += corr.gen_impl + "\n\n"
  end
  s
end

def gen_extern_impl
  s = ""
  $corr_list.each do |corr|
    s += corr.gen_extern_calls + "\n\n"
  end
  s
end

def gen_correlations
  s = ""
  $corr_list.each do |corr|
    s += corr.gen_class + "\n\n"
  end
  s
end

options = {}
options_parser = OptionParser.new do |opts|

  opts.on('-f NAME', '--file NAME', 
          'file name with correlations') do |file_name|
    options[:file_name] = file_name
  end

  opts.on('-H', '--header', 'generate header with c++ correlations') do
    options[:header] = true
  end

  opts.on('-C NAME', '--c++ NAME',
          'generate c++ correlation implementation') do |corr_name|
    options[:corr_name] = corr_name
  end

  opts.on('-P', '--pars-set', 'generate parameters class for global parameters') do
    options[:pars] = true
  end

  opts.on('-j', '--json', 'generate json of parameters') do
    options[:json] = true
  end

  opts.on('-e NAME', '--eq NAME',
          'generate equation (if defined) for correlation NAME') do |corr_name|
    options[:eq] = corr_name
  end

  opts.on('-E', '--equations', 'generate all equations') do
    options[:equations] = true
  end

  opts.on('-X', '--extern-calls', 'generate extern calls') do
    options[:extern] = true
  end

  opts.on('-d NAME', '--dir NAME',
          'Target directory where equations will be generated') do |dir|
    options[:dir] = dir
  end

  opts.on('-n', '--par-names', 'print union of all parameter names') do
    options[:par_names] = true
  end
  
end

options_parser.parse!

file = options[:file_name]
$eq_dir = options[:dir] || '../eqs'

fail 'correlations file not specified' if file.nil?

require 'bibtex'
$biblio = options[:biblio] || "#{pvt}/include/correlations/refs.bib"
$bib_db = BibTeX.open($biblio)

def add_ref(tag)
  fail "Tag #{tag} no found in database #{$biblio}" unless $bib_db.has_key? tag
  $curr_corr.add_ref(tag)
end

load file

if options[:json]
  puts $subtype.to_json
  exit
end

if options[:par_names]
  puts $pars_set.entries.join ', '
  exit
end

if options[:equations]
  $corr_list.each { |corr| corr.make_eq($eq_dir) }
  exit
end

if options[:pars]
  puts $subtype.gen_pars_set_class
  exit
end

if options[:header]  
  guard_name = file.gsub '-', '_'
  guard_name.gsub! '.', '_'
  guard_name.gsub! 'rb', 'H'
  guard_name.upcase!

  puts "# ifndef #{guard_name}\n"\
       "# define #{guard_name}\n"\
       "\n"\
       "# include <ah-dispatcher.H>\n"\
       "# include <units.H>\n"\
       "# include <pvt-exceptions.H>\n"\
       "# include <correlations/correlation.H>\n"\
       "\n"\
       "#{$subtype.gen_subtype_class}\n"\
       "\n"\
       "#{gen_correlations}\n"\
       "\n"\
       " # endif // #{guard_name}"  
  exit
end

if options[:extern]
  guard_name = File.basename file, '.rb'
  header_name = guard_name + ".H"
  guard_name += "_calls_H"
  guard_name.gsub! '-', '_'
  guard_name.gsub! '.', '_'
  guard_name.upcase!
  puts "#{gen_extern_impl}\n"
  exit
end

require 'open3'

def search_corr(corr_name)
  corr = $corr_list.find { |c| c.name.upcase == corr_name.upcase }
  fail "correlation #{corr_name} not found" unless corr
  corr
end

corr_name = options[:corr_name]
if corr_name
  corr = search_corr(corr_name)
  # File.open('tmp', "w+").write("#{corr.gen_impl}")
  # stdout, stderr, exit_status = Open3.capture3('cat tmp')
  # puts stdout
  # puts stderr
  # puts exit_status
  puts "#{corr.gen_impl}\n"\
       "\n"
  exit
end

eq = options[:eq]
dir = options[:dir]
if eq
  corr = search_corr(eq)
  corr.gen_eq(dir)
  exit
end

guard_name = File.basename file, '.rb'
header_name = guard_name + ".H"
guard_name += "_impl_H"
guard_name.gsub! '-', '_'
guard_name.gsub! '.', '_'
guard_name.upcase!

puts "# ifndef #{guard_name}"
puts "# define #{guard_name}"
puts 
puts "# include <correlations/#{header_name}>"
puts
puts "#{gen_impl_declarations}\n"\
     "\n"\
     " # endif // #{guard_name}"

