#!/usr/bin/env ruby
# -*- coding: iso-8859-1 -*-

require 'fileutils'
require 'optparse'
require 'json'

pvt = ENV['PVT']

options = {}
options_parser = OptionParser.new do |opts|

  opts.on('-1 NAME', '--subtype1 NAME', 
          'first file name with correlations') do |file_name|
    options[:file_name1] = file_name
  end

  opts.on('-2 NAME', '--subtype2 NAME', 
          'second file name with correlations') do |file_name|
    options[:file_name2] = file_name
  end

  opts.on('-n NAME', '--name NAME', 'Compound correlation name') do |corr_name|
    options[:corr_name] = corr_name
  end

end

options_parser.parse!

corr_name = options[:corr_name]
fail "Compound correlation name has not been specified" unless corr_name

file1 = options[:file_name1]
file2 = options[:file_name2]

fail "not first correlation definition file has been given" unless file1
fail "not second correlation definition file has been given" unless file2

info1 = JSON.parse(`"#{pvt}"/bin/gen-corr -f #{file1} -j`)
info2 = JSON.parse(`"#{pvt}"/bin/gen-corr -f #{file2} -j`)

def gen_pars_set_class(corr_name, info1, info2)
  methods1, class1 = info1
  methods2, class2 = info2
  names = []
  corr_name = corr_name + 'Pars'
  s = "template <class Corr1, class Corr2>\n"\
      "class #{corr_name}\n"\
      "{\n"\
      "\n"\
      "  Corr1* corr1_ptr = nullptr;\n"\
      "\n"\
      "  Corr2* corr2_ptr = nullptr;\n"\
      "\n"\
      "public:\n"\
      "\n"\
      "  #{corr_name}(Corr1 * ptr1, Corr2 * ptr2)\n"\
      "    : corr1_ptr(ptr1), corr2_ptr(ptr2) {}\n"\
      "\n"\
      "  Corr1 * corr1_me() const { return corr1_ptr; }\n"\
      "\n"\
      "  Corr2 * corr2_me() const { return corr2_ptr; }\n"\
      "\n"
  methods1.each do |name, unit|
    names << [name, unit]
    s += "  void set_#{name}(const Quantity<#{unit}> & #{name})\n"\
         "  {\n"\
         "    corr1_me()->set_#{name}(#{name});\n"
    s += "    corr2_me()->set_#{name}(#{name});\n" if methods2.has_key? name
    s += "  }\n"\
         "\n"\
         "private:\n"\
         "\n"\
         "  static void __set_#{name}(#{corr_name} * ptr, double val, const Unit & unit)\n"\
         "  {\n"\
         "    ptr->set_#{name}(VtlQuantity(unit, val));\n"\
         "  }\n"\
         "\n"\
         "public:\n"\
         "\n"
  end
  methods2.each do |name, unit|
    if !methods1.has_key? name
      names << [name, unit]
      s += "  void set_#{name}(const Quantity<#{unit}> & #{name})\n"\
           "  {\n"\
           "    corr2_me()->set_#{name}(#{name});\n"\
           "  }\n"\
           "private:\n"\
           "\n"\
           "  static void __set_#{name}(#{corr_name} * ptr, double val, const Unit & unit)\n"\
         "  {\n"\
         "    ptr->set_#{name}(VtlQuantity(unit, val));\n"\
         "  }\n"\
         "\n"\
         "public:\n"\
         "\n"
    end
  end
  s += "\n"\
       "void set_par(const string & name, double val, const Unit & unit)\n"\
       "{\n"\
       "  static AHDispatcher<string,\n"\
       "                      void (*)(#{corr_name}*, double, const Unit&)>\n"\
       "    dispatcher = \n"\
       "  {\n"
  names.each_with_index do |item, i|
    name, unit = item
    s += "\"#{name}\", __set_#{name}"
    s += ",\n" unless i == names.length - 1
  end
  s += "};\n"\
         "\n"\
         "  dispatcher.run(name, this, val, unit);\n"\
         "}\n"\
         "\n"\
         "void set_par(const Correlation::NamedPar & par)\n"\
         "{\n"\
         "  this->set_par(get<1>(par), get<2>(par), *get<3>(par));\n"\
         "}\n"\
         "\n"\
         "};\n"
end

guard_name = "#{corr_name.upcase}_COMPOUND_H"
puts "# ifndef #{guard_name}\n"\
     "# define #{guard_name}\n"\
     "\n"\
     "# include <correlations/pvt-correlations.H>\n"\
     "# include <correlations/compound-corr.H>\n"\
     "# include <correlations/#{File.basename(file1, '.rb')}.H>\n"\
     "# include <correlations/#{File.basename(file2, '.rb')}.H>\n"\
     "\n"\
     "#{gen_pars_set_class(corr_name, info1, info2)}\n"\
     "\n"\
     "using #{corr_name} =\n"\
     "  CompoundCorrelation<#{info1[1]}, #{info2[1]}, #{corr_name}Pars>;"\
     "# endif"




