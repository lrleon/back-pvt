#!/usr/bin/env ruby
# -*- coding: iso-8859-1 -*-

require 'fileutils'
require 'optparse'
require 'json'

pvt = ENV['PVT']

options = {}
options_parser = OptionParser.new do |opts|

  opts.on('-1 NAME', '--subtype1 NAME', 
          'first file name with correlations') do |file_name|
    options[:file_name1] = file_name
  end

  opts.on('-2 NAME', '--subtype2 NAME', 
          'second file name with correlations') do |file_name|
    options[:file_name2] = file_name
  end

  opts.on('-n NAME', '--name NAME', 'Compound correlation name') do |corr_name|
    options[:corr_name] = corr_name
  end

end

options_parser.parse!

corr_name = options[:corr_name]
fail "Compound correlation name has not been specified" unless corr_name

file1 = options[:file_name1]
file2 = options[:file_name2]

fail "not first correlation definition file has been given" unless file1
fail "not second correlation definition file has been given" unless file2

info1 = JSON.parse(`"#{pvt}"/bin/gen-corr -f #{file1} -j`)
info2 = JSON.parse(`"#{pvt}"/bin/gen-corr -f #{file2} -j`)


def gen_compound_corr(corr_name, info1, info2)
  methods1, class1 = info1
  methods2, class2 = info2
  names = []
  s = "struct #{corr_name} :\n"\
      "  protected CompoundCorrelation<#{class1}, #{class2}>\n"\
      "{\n"
  methods1.each do |name, unit|
    names << [name, unit]
    s += "  void set_#{name}(const Quantity<#{unit}> & #{name})\n"\
         "  {\n"\
         "    #{class1}::set_#{name}(#{name});\n"
    s += "    #{class2}::set_#{name}(#{name});\n" if methods2.has_key? name
    s += "  }\n"\
         "\n"\
         "private:\n"\
         "\n"\
         "  static void __set_#{name}(#{corr_name} * ptr, double val, const Unit & unit)\n"\
         "  {\n"\
         "    ptr->set_#{name}(VtlQuantity(unit, val));\n"\
         "  }\n"\
         "\n"\
         "public:\n"\
         "\n"
  end
  methods2.each do |name, unit|
    if !methods1.has_key? name
      names << [name, unit]
      s += "  void set_#{name}(const Quantity<#{unit}> & #{name})\n"\
           "  {\n"\
           "    #{class1}::set_#{name}(#{name});\n"\
           "  }\n"
    end
  end
  s += "\n"\
       "void set_par(const string & name, double val, const Unit & unit)\n"\
       "{\n"\
       "  static AHDispatcher<string,\n"\
       "                      void (*)(#{corr_name}*, double, const Unit&)>\n"\
       "    dispatcher = \n"\
       "  {\n"
  names.each_with_index do |item, i|
    name, unit = item
    s += "#{name}, __set_#{name}"
    s += ",\n" unless i == names.length - 1
  end
  s += "};\n"\
         "\n"\
         "  dispatcher.run(name, this, val, unit);\n"\
         "}\n"\
         "\n"\
         "};\n"
end

guard_name = "#{corr_name.upcase}_COMPOUND.H"
puts "# ifndef #{guard_name}\n"\
     "# define #{guard_name}\n"\
     "\n"\
     "# include <correlations/#{info1[1]}.H>\n"\
     "# include <correlations/#{info2[1]}.H>\n"\
     "\n"\
     "#{gen_compound_corr(corr_name, info1, info2)}\n"\
     "\n"\
     "# endif"




