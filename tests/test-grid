#!/usr/bin/env ruby
# -*- coding: iso-8859-1 -*-

require 'optparse'
require 'fileutils'

load 'correlations.rb'

options = {}
options_parser = OptionParser.new do |opts|

  opts.on('-z ZENCSV', '--zen ZENCSV', 'csv file by zen') do |property_name|
    options[:zen_name] = property_name
  end

  opts.on('-p PCSV', '--pe PCSV',
          'csv file by Petroleum Experts') do |property_name|
    options[:pe_name] = property_name
  end

end

options_parser.parse!

zen_name = options[:zen_name]
fail 'zen csv file not given' unless zen_name

pe_name = options[:pe_name]
fail 'pe csv file not given' unless pe_name

require 'csv'

zen_rows = CSV.read(zen_name, headers: true)
pe_rows = CSV.read(pe_name, headers: true)

zen_headers = zen_rows.headers
zen_units = zen_headers.map { |h|l = h.split; [l[0], l[1]] }.to_h
zen_names = zen_headers.map { |h| [h.split[0], h] }.to_h

pe_headers = pe_rows.headers
pe_units = pe_headers.map { |h| l = h.split; [l[0], l[1]] }.to_h
pe_names = pe_headers.map { |h| [h.split[0], h] }.to_h

def map_values(rows, names)
  vals = rows.map do |row|
    t = row[names['t']]
    p = row[names['p']]
    [[t, p], row]
  end.to_h  
end

def access(row, names, name)
  val = row[names[name]]
  fail "name #{name} not found" unless val
  val.to_f
end

def build_table(zen_vals, pe_vals, zen_names, pe_names)
  zen_vals.map do |pair, row|
    t = pair[0].to_f
    p = pair[1].to_f
    pe_row = pe_vals[pair]

    zen_pb = access row, zen_names, 'pb'
    pe_pb = access pe_row, pe_names, 'pb'
    pb_error = 100*(pe_pb - zen_pb).abs / pe_pb

    zen_rs = access row, zen_names, 'rs'
    pe_rs = access pe_row, pe_names, 'rs'
    rs_error = 100*(pe_rs - zen_rs).abs / pe_rs

    zen_bo = access row, zen_names, 'bo'
    pe_bo = access pe_row, pe_names, 'bo'
    bo_error = 100*(pe_bo - zen_bo).abs / pe_bo

    zen_uo = access row, zen_names, 'uo'
    pe_uo = access pe_row, pe_names, 'uo'
    uo_error = 100*(pe_uo - zen_uo).abs / pe_uo

    [t, p, zen_pb, pe_pb, pb_error, zen_rs, pe_rs, rs_error,
     zen_bo, pe_bo, bo_error, zen_uo, pe_uo, uo_error]
  end
end

def format_table(table, decs = 3)
  lens = Array.new(table[0].size, 0)
  table.each do |l|
    lens = lens.zip(l).map { |len, i| [len, i.round(decs).to_s.size].max }
  end
  header = ["t", "p", "pb zen", "pb_pe", "", "rs zen", "rs pe", "",
   "bo zen", "bo pe", "", "uo zen", "uo pe", ""].
    zip(lens).map { |i, len| i.ljust(len) }
  [header, table.map do |l|
    l.zip(lens).map { |i, len| i.round(decs).to_s.ljust(len) }
  end]
end
  
table = build_table(map_values(zen_rows, zen_names),
                    map_values(pe_rows, pe_names), zen_names, pe_names)

lines = format_table(table)

lines[0].each do |i|
  print i
  print ' ' if i != lines[0].last
end
puts

lines[1].each do |l|
  print "#{l[0]} #{l[1]} "
  l.drop(2).each_slice(3) do |s|
    print "#{s[0]} #{s[1]} #{s[2]} %"
    print ' ' if s != l.last
  end
  puts
end
