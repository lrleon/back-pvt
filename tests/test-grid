#!/usr/bin/env ruby
# -*- coding: iso-8859-1 -*-

require 'optparse'
require 'fileutils'

load 'correlations.rb'

require 'csv'
require 'solid_assert'

SolidAssert.enable_assertions

class Table

  private
  
  def map_values(rows, names)
    vals = rows.map do |row|
      t = row[names['t']]
      p = row[names['p']]
      [[t, p], row]
    end.to_h  
  end

  def access(vals, names, name)
    vals.map { |pair, row| [pair, row[names[name]].to_f] }.to_h
  end

  def access_convert(vals, names, name)
    m = vals.map { |pair, row| [pair, row[names[name]]] }
    zen_unit = @zen_units[name]
    pe_unit = @pe_units[name]
    if zen_unit != pe_unit
      v = m.map { |e| e[1] }.join ' '
      #puts "**** #{v}"
      vc = `echo #{v} | ./test-conversion -p -S #{pe_unit} -T #{zen_unit}`.split
      m.zip(vc).map { |m, v| [m[0], v.to_f] }.to_h
    else
      m.map { |e| [e[0], e[1].to_f] }.to_h
    end
  end

  def errors(h1, h2)
    h1.map do |pair, v1|
      v2 = h2[pair]
      err = 100*(v1 - v2).abs / v2
      #puts "#{pair[0]} #{pair[1]} = #{v1} ~ #{v2} = #{err}"
      [pair, err]
    end.to_h
  end

  def combine(zen_hash, pe_hash, error_hash)
    zen_hash.map { |pair, val| [val, pe_hash[pair], error_hash[pair]] }
  end

  def get_property(name, zen_vals, pe_vals, zen_names, pe_names)
    zen_v = access zen_vals, zen_names, name
    pe_v = access_convert pe_vals, pe_names, name
    error_v = errors zen_v, pe_v
    combine zen_v, pe_v, error_v
  end

  def build_table(zen_vals, pe_vals, zen_names, pe_names)
    keys = zen_vals.map do |pair, row|
      pe_row = pe_vals[pair]
      fail "pe entry for t = #{pair[0]} p = #{pair[1]} not found" unless pe_row
      [pair[0].to_f, pair[1].to_f]
    end

    pb = get_property 'pb', zen_vals, pe_vals, zen_names, pe_names
    rs = get_property 'rs', zen_vals, pe_vals, zen_names, pe_names
    bo = get_property 'bo', zen_vals, pe_vals, zen_names, pe_names
    uo = get_property 'uo', zen_vals, pe_vals, zen_names, pe_names
    po = get_property 'po', zen_vals, pe_vals, zen_names, pe_names
    
    values = pb.zip(rs, bo, uo, po).map { |e| e.inject(:+) }
    #values.each do |e|
     # puts "#{e}"
    #end

    keys.zip(values).to_h
  end

  public
  
  attr_reader :table

  def initialize(zen_name, pe_name)
    zen_rows = CSV.read(zen_name, headers: true)
    pe_rows = CSV.read(pe_name, headers: true)

    zen_headers = zen_rows.headers
    @zen_units = zen_headers.map { |h| l = h.split; [l[0], l[1]] }.to_h
    zen_names = zen_headers.map { |h| [h.split[0], h] }.to_h

    pe_headers = pe_rows.headers
    @pe_units = pe_headers.map { |h| l = h.split; [l[0], l[1]] }.to_h
    pe_names = pe_headers.map { |h| [h.split[0], h] }.to_h

    @table = build_table(map_values(zen_rows, zen_names),
                         map_values(pe_rows, pe_names), zen_names, pe_names)
  end

  def format(decs = 2)
    table = @table.map { |k, vals| k + vals }
    lens = Array.new(table[0].size, 0)
    table.each do |l|
      lens = lens.zip(l).map { |len, i| [len, i.round(decs).to_s.size].max }
    end
    header = ['t', 'p', 'pb zen', 'pb pe', 'pb %', 'rs zen', 'rs pe', 'rs %',
              'bo zen', 'bo pe', 'bo %', 'uo zen', 'uo pe', 'uo %',
             'po zen', 'po pe', 'po %']
    grid = table.map { |l| l.map { |i| i.round(decs).to_s } }
    grid.unshift header
    grid.map { |l| l.zip(lens).map { |i, len| i.ljust(len) } }
  end

  def get_entry(p, t) @table[[t, p]] end

  private
  
  def values(p, t, i)
    e = get_entry t, p
    fail "temperature = #{t} pressure = #{p} pair not found" unless e
    [e[i], e[i + 1], e[i + 2].round(2)]
  end

  public
  
  def to_s(name, t) " #{name} = #{t[0]} #{t[1]} #{t[2].round(2)}" end

  def pb(t, p) values t, p, 0 end

  def rs(t, p) values t, p, 3 end

  def bo(t, p) values t, p, 6 end

  def uo(t, p) values t, p, 9 end

  def po(t, p) values t, p, 11 end

  def pb_s(t, p) "#{t} #{p}" + to_s('pb', pb(t, p)) end

  def rs_s(t, p) "#{t} #{p}" + to_s('rs', rs(t, p)) end

  def bo_s(t, p) "#{t} #{p}" + to_s('bo', bo(t, p)) end

  def uo_s(t, p) "#{t} #{p}" + to_s('uo', uo(t, p)) end

  def po_s(t, p) "#{t} #{p}" + to_s('po', po(t, p)) end

  def subset(i, per)
    list = @table.select { |k, vals| vals[i + 2] >= per }.
           map { |k, vals| k + [vals[i], vals[i + 1], vals[i + 2]] }.
           map { |e| "#{e[0]} #{e[1]} #{e[2]} #{e[3]} #{e[4]}" }
  end

  def pb_subset(per) subset 0, per end

  def rs_subset(per) subset 3, per end

  def bo_subset(per) subset 6, per end

  def uo_subset(per) subset 9, per end

  def po_subset(per) subset 11, per end
end

options = {}
options_parser = OptionParser.new do |opts|

  opts.on('-z ZENCSV', '--zen ZENCSV', 'csv file by zen') do |property_name|
    options[:zen_name] = property_name
  end

  opts.on('-p PCSV', '--pe PCSV',
          'csv file by Petroleum Experts') do |property_name|
    options[:pe_name] = property_name
  end

  opts.on('-T TEMP', '--temp TEMP', 'temperature value') do |temp|
    options[:temp] = temp
  end

  opts.on('-P PRESSURE', '--pressure PRESSURE', 'pressure value') do |pressure|
    options[:pressure] = pressure
  end

  opts.on('-G PROPERTY', '--get PROPERTY', 'Property name') do |property|
    options[:property] = property
  end

  opts.on('-% PERCENTAGE', '--percentage PERCENTAGE',
          'error percentage') do |per|
    options[:per] = per
  end
end

options_parser.parse!

zen_name = options[:zen_name]
fail 'zen csv file not given' unless zen_name

pe_name = options[:pe_name]
fail 'pe csv file not given' unless pe_name
  
data = Table.new(zen_name, pe_name)

t = options[:temp]
p = options[:pressure]
missing = (t && !p) || (!t && p)
value_requested = t && p

fail 'option -T temp and -P pressure must be used together' if missing

if value_requested
  property = options[:property]
  fail 'Property has not been specified' unless property
  val = nil
  case property.downcase
  when 'pb'
    val = data.pb_s(t.to_f, p.to_f)
  when 'rs'
    val = data.rs_s(t.to_f, p.to_f)
  when 'bo'
    val = data.bo_s(t.to_f, p.to_f)
  when 'uo'
    val = data.uo_s(t.to_f, p.to_f)
  when 'po'
    val = data.po_s(t.to_f, p.to_f)
  else
    fail "invalid property #{property}"
  end
  puts val
  exit
end

per = options[:per].to_f if options[:per]
if per
  property = options[:property]
  fail "Property has not been specified" unless property
  fail "% must between 1 and 99" if per < 0.01 || per > 99
  case property.downcase
  when 'pb'
    vals = data.pb_subset(per)
  when 'rs'
    vals = data.rs_subset(per)
  when 'bo'
    vals = data.bo_subset(per)
  when 'uo'
    vals = data.uo_subset(per)
  when 'po'
    vals = data.po_subset(per)
  else
    fail "invalid property #{property}"
  end
  vals.each { |e| puts e }
  exit
end

lines = data.format

lines.each do |l|
  print "#{l[0]} #{l[1]} "
  l.drop(2).each_slice(3) do |s|
    print "#{s[0]} #{s[1]} #{s[2]}"
    print ' ' if s != l.last
  end
  puts
end
