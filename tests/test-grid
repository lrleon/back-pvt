#!/usr/bin/env ruby
# -*- coding: iso-8859-1 -*-

require 'optparse'
require 'fileutils'

load 'correlations.rb'

require 'csv'
require 'solid_assert'

SolidAssert.enable_assertions

class Table

  private
  
  def map_values(rows, names)
    rows.map do |row|
      t = row[names['t']]
      p = row[names['p']]
      [[t, p], row]
    end.to_h  
  end

  def access(vals, names, name)
    vals.map { |pair, row| [pair, row[names[name]].to_f] }.to_h
  end

  def access_convert(vals, names, name)
    m = vals.map { |pair, row| [pair, row[names[name]]] }
    zen_unit = @zen_units[name]
    pe_unit = @pe_units[name]
    if zen_unit != pe_unit
      v = m.map { |e| e[1] }.join ' '
      vc = `echo #{v} | ./test-conversion -p -S #{pe_unit} -T #{zen_unit}`.split
      m.zip(vc).map { |m, v| [m[0], v.to_f] }.to_h
    else
      m.map { |e| [e[0], e[1].to_f] }.to_h
    end
  end

  def errors(h1, h2)
    h1.map do |pair, v1|
      v2 = h2[pair]
      err = 100*(v1 - v2).abs / v2
      [pair, err]
    end.to_h
  end

  def combine(zen_hash, pe_hash, error_hash)
    zen_hash.map { |pair, val| [val, pe_hash[pair], error_hash[pair]] }
  end

  def get_property(name, zen_vals, pe_vals, zen_names, pe_names)
    zen_v = access zen_vals, zen_names, name
    pe_v = access_convert pe_vals, pe_names, name
    error_v = errors zen_v, pe_v
    combine zen_v, pe_v, error_v
  end

  def build_table(zen_vals, pe_vals, zen_names, pe_names)
    keys = zen_vals.map do |pair, row|
      pe_row = pe_vals[pair]
      fail "pe entry for t = #{pair[0]} p = #{pair[1]} not found" unless pe_row
      [pair[0].to_f, pair[1].to_f]
    end

    pb = get_property 'pb', zen_vals, pe_vals, zen_names, pe_names
    rs = get_property 'rs', zen_vals, pe_vals, zen_names, pe_names
    bo = get_property 'bo', zen_vals, pe_vals, zen_names, pe_names
    uo = get_property 'uo', zen_vals, pe_vals, zen_names, pe_names
    po = get_property 'po', zen_vals, pe_vals, zen_names, pe_names
    z = get_property 'zfactor', zen_vals, pe_vals, zen_names, pe_names
    
    values = pb.zip(rs, bo, uo, po, z).map { |e| e.inject(:+) }

    @zen_vals = zen_vals

    keys.zip(values).to_h
  end

  public
  
  attr_reader :table

  def initialize(zen_name, pe_name)
    zen_rows = CSV.read(zen_name, headers: true)
    pe_rows = CSV.read(pe_name, headers: true)

    zen_headers = zen_rows.headers
    @zen_units = zen_headers.map { |h| l = h.split; [l[0], l[1]] }.to_h
    @zen_names = zen_headers.map { |h| [h.split[0], h] }.to_h

    pe_headers = pe_rows.headers
    @pe_units = pe_headers.map { |h| l = h.split; [l[0], l[1]] }.to_h
    pe_names = pe_headers.map { |h| [h.split[0], h] }.to_h

    @table = build_table(map_values(zen_rows, @zen_names),
                         map_values(pe_rows, pe_names), @zen_names, pe_names)
  end

  @@header = ['t', 'p', 'pb zen', 'pb pe', 'pb %', 'rs zen', 'rs pe', 'rs %',
              'bo zen', 'bo pe', 'bo %', 'uo zen', 'uo pe', 'uo %',
              'po zen', 'po pe', 'po %', 'z zen', 'z pe', 'z %']

  def format(thash = @table, decs = 2)
    table = thash.map { |k, vals| k + vals }
    grid = table.map { |l| l.map { |i| i.round(decs).to_s } }
    grid.unshift @@header.map { |h| @zen_units[h.split[0]] || "" }
    grid.unshift @@header
    lens = Array.new(grid[0].size, 0)
    grid.each do |l|
      lens = lens.zip(l).map { |len, i| [len, i.size].max }
    end.map { |l| l.zip(lens).map { |i, len| i.ljust(len) } }
  end

  def get_entry(t, p)
    entry = table[[t.to_f, p.to_f]]
    fail "entry for t = #{t} p = #{p} not found" unless entry
    entry
  end

  def get_zen_entry(t, p)
    entry = @zen_vals[[t, p]]
    fail "entry for t = #{t} p = #{p} not found" unless entry
    grid = [@zen_names.keys, @zen_units.values, entry.map { |_,v| v }]
    lens = Array.new(@zen_names.size, 0)
    grid.each do |l|
      lens = lens.zip(l).map { |len, i| [len, i.size].max }
    end
    grid.map { |l| l.zip(lens).map { |i, len| i.ljust(len) } }.each do |l|
      l.each do |e|
        print "#{e}" 
        print ' ' if e != l.last
      end
      puts
    end
  end

  def entry_s(t, p)
    row = get_entry t, p
    a = [[[t.to_f, p.to_f], row]]
    format a.to_h
  end

  def values(t, p, i)
    e = get_entry t, p
    [e[i], e[i + 1], e[i + 2].round(2)]
  end

  def to_s(name, t) " #{name} = #{t[0]} #{t[1]} #{t[2].round(2)}" end

  def pb(t, p) values t, p, 0 end

  def rs(t, p) values t, p, 3 end

  def bo(t, p) values t, p, 6 end

  def uo(t, p) values t, p, 9 end

  def po(t, p) values t, p, 12 end

  def z(t, p) values t, p, 15 end

  def pb_s(t, p) "#{t} #{p}" + to_s('pb', pb(t, p)) end

  def rs_s(t, p) "#{t} #{p}" + to_s('rs', rs(t, p)) end

  def bo_s(t, p) "#{t} #{p}" + to_s('bo', bo(t, p)) end

  def uo_s(t, p) "#{t} #{p}" + to_s('uo', uo(t, p)) end

  def po_s(t, p) "#{t} #{p}" + to_s('po', po(t, p)) end

  def z_s(t, p) "#{t} #{p}" + to_s('z', po(t, p)) end

  def subset(i, per)
    list = @table.select { |k, vals| vals[i + 2] >= per }.
           map { |k, vals| k + [vals[i], vals[i + 1], vals[i + 2]] }.
           map { |e| "#{e[0]} #{e[1]} #{e[2]} #{e[3]} #{e[4].round(2)}" }
  end

  def pb_subset(per) subset 0, per end

  def rs_subset(per) subset 3, per end

  def bo_subset(per) subset 6, per end

  def uo_subset(per) subset 9, per end

  def po_subset(per) subset 12, per end

  def z_subset(per) subset 15, per end
end

options = {}
options_parser = OptionParser.new do |opts|

  opts.on('-z ZENCSV', '--zen ZENCSV', 'csv file by zen') do |property_name|
    options[:zen_name] = property_name
  end

  opts.on('-p PCSV', '--pe PCSV',
          'csv file by Petroleum Experts') do |property_name|
    options[:pe_name] = property_name
  end

  opts.on('-T TEMP', '--temp TEMP', 'temperature value') do |temp|
    options[:temp] = temp
  end

  opts.on('-P PRESSURE', '--pressure PRESSURE', 'pressure value') do |pressure|
    options[:pressure] = pressure
  end

  opts.on('-G PROPERTY', '--get PROPERTY', 'Property name') do |property|
    options[:property] = property
  end

  opts.on('-Z', '--ZEN', 'Zen Property name') do |property|
    options[:zen_property] = true
  end

  opts.on('-R', '--R', 'generate R code for -G property') do |property|
    options[:R] = true
  end

  opts.on('-% PERCENTAGE', '--percentage PERCENTAGE',
          'error percentage') do |per|
    options[:per] = per
  end
end

options_parser.parse!

zen_name = options[:zen_name]
fail 'zen csv file not given' unless zen_name

pe_name = options[:pe_name]
fail 'pe csv file not given' unless pe_name
  
data = Table.new(zen_name, pe_name)

t = options[:temp]
p = options[:pressure]
missing = (t && !p) || (!t && p)
property = options[:property]
property.downcase! if property
value_requested = t && p && property

fail 'option -T temp and -P pressure must be used together' if missing

if value_requested
  mtd_name = property + '_s'
  fail "invalid property #{property}" unless data.respond_to? mtd_name
  puts data.send mtd_name, t, p
  exit
end

per = options[:per].to_f if options[:per]
if per
  fail "Property has not been specified" unless property
  fail "% must between 1 and 99" if per < 0.01 || per > 99
  mtd_name = property + '_subset'
  fail "invalid property #{property}" unless data.respond_to? mtd_name
  data.send(mtd_name, per).each { |e| puts e }
  exit
end

zen_property = options[:zen_property]

if t && p
  if zen_property
    data.get_zen_entry t, p
    exit
  elsif
    lines = data.entry_s(t, p)
  end
else
  lines = data.format
end

if options[:R]
  fail "Not yet implemented"
end

fail "Property request (option -G) without t and p parameters" if property

lines.each do |l|
  print "#{l[0]} #{l[1]} "
  l.drop(2).each_slice(3) do |s|
    print "#{s[0]} #{s[1]} #{s[2]}"
    print ' ' if s != l.last
  end
  puts
end
