#!/usr/bin/env ruby
# -*- coding: iso-8859-1 -*-

require 'optparse'
require 'fileutils'

load 'correlations.rb'

require 'csv'
require 'solid_assert'

SolidAssert.enable_assertions

class Table

  def map_values(rows, names)
    rows.map do |row|
      t = row[names['t']]
      p = row[names['p']]
      [[t, p], row]
    end.to_h  
  end

  def access(vals, names, name)
    vals.map { |pair, row| [pair, row[names[name]].to_f] }.to_h
  end

  def access_and_convert(vals, names, name)
    m = vals.map { |pair, row| [pair, row[names[name]]] }
    zen_unit = @zen_units[name]
    pe_unit = @pe_units[name]
    if zen_unit != pe_unit
      v = m.map { |e| e[1] }.join ' '
      vc = `echo #{v} | ./test-conversion -p -S #{pe_unit} -T #{zen_unit}`.split
      m.zip(vc).map { |m, v| [m[0], v.to_f] }.to_h
    else
      m.map { |e| [e[0], e[1].to_f] }.to_h
    end
  end

  def errors(h1, h2)
    h1.map do |pair, v1|
      v2 = h2[pair]
      err = 100*(v1 - v2).abs / v2
      [pair, err]
    end.to_h
  end

  def combine(zen_hash, pe_hash, error_hash)
    zen_hash.map { |pair, val| [val, pe_hash[pair], error_hash[pair]] }
  end

  def get_property(name, zen_vals, pe_vals, zen_names, pe_names)
    zen_v = access zen_vals, zen_names, name
    pe_v = access_and_convert pe_vals, pe_names, name
    error_v = errors zen_v, pe_v
    combine zen_v, pe_v, error_v
  end

  @@header = ['t', 'p', 'pb zen', 'pb pe', 'pb %', 'rs zen', 'rs pe', 'rs %',
              'bo zen', 'bo pe', 'bo %', 'uo zen', 'uo pe', 'uo %',
              'po zen', 'po pe', 'po %', 'z zen', 'z pe', 'z %']

  def format(thash = @table, decs = 2)
    table = thash.map { |k, vals| k + vals }
    grid = table.map { |l| l.map { |i| i.round(decs).to_s } }
    grid.unshift @@header.map { |h| @zen_units[h.split[0]] || "" }
    grid.unshift @@header
    lens = Array.new(grid[0].size, 0)
    grid.each do |l|
      lens = lens.zip(l).map { |len, i| [len, i.size].max }
    end.map { |l| l.zip(lens).map { |i, len| i.ljust(len) } }
  end

  def get_entry(t, p)
    entry = table[[t.to_f, p.to_f]]
    fail "entry for t = #{t} p = #{p} not found" unless entry
    entry
  end

  def get_zen_entry(t, p)
    entry = @zen_vals[[t, p]]
    fail "entry for t = #{t} p = #{p} not found" unless entry
    grid = [@zen_names.keys, @zen_units.values, entry.map { |_,v| v }]
    lens = Array.new(@zen_names.size, 0)
    grid.each do |l|
      lens = lens.zip(l).map { |len, i| [len, i.size].max }
    end
    grid.map { |l| l.zip(lens).map { |i, len| i.ljust(len) } }.each do |l|
      l.each do |e|
        print "#{e}" 
        print ' ' if e != l.last
      end
      puts
    end
  end

  def entry_s(t, p)
    row = get_entry t, p
    a = [[[t.to_f, p.to_f], row]]
    format a.to_h
  end

  def values(t, p, i)
    e = get_entry t, p
    [e[i], e[i + 1], e[i + 2].round(2)]
  end

  def to_R(pair) "#{pair[0]} <- c(#{pair[1].join(',')})" end

  def plot_R(xpair, ypair, *yrest)
    s = "#{to_R(xpair)}\n"\
        "#{to_R(ypair)}\n"
    yrest.each { |pair| s += "#{to_R(pair)}\n" }
    ys = ypair[1] + yrest.map{ |e| e[1] }
    ymax = ys.min
    ymin = ys.max
    s += "plot(#{xpair[0]}, #{ypair[0]}, ylim=c(#{ymin}, #{ymax}))"
    cnames = ypair[0]
    yrest.each_with_index do |pair, i|
      s += "lines(#{xpair[0]}, #{pair[0]}, col = #{i+1})\n"
      cnames << pair[0]
    end
    s += "#{to_R(['cnames', cnames])}\n"
         "#{to_R(['cols', 1..yrest.size - 1])}\n"
  end

  def to_s(name, t) " #{name} = #{t[0]} #{t[1]} #{t[2].round(2)}" end

  def subset(i, per)
    list = @table.select { |k, vals| vals[i + 2] >= per }.
           map { |k, vals| k + [vals[i], vals[i + 1], vals[i + 2]] }.
           map { |e| "#{e[0]} #{e[1]} #{e[2]} #{e[3]} #{e[4].round(2)}" }
  end

  @@properties = ['pb', 'rs', 'bo', 'uo', 'po', 'zfactor']

  def check_property(property) @@properties.include? property end

  def pressures(property)
    property_index = @@properties.find_index property
    fail "property #{property} not found" unless property_index
    property_index = 3*property_index + 1
    pressures = {}
    @table.each do |pair, vals|
      p = pair[1]
      val = vals[property_index]
      entry = pressures[p]
      if entry
        entry << val
      else
        pressures[p] = [val]
      end
    end
    pressures
  end

  def self.define_components(name, offset)
    define_method(name) do |t, p|
      values t, p, offset
    end
    define_method(name + '_s' ) do |t, p|
      "#{t} #{p}" + to_s(name, send(name, t, p))
    end
    define_method(name + '_subset' ) do |per|
      subset offset, per
    end
  end

  def build_tables(zen_vals, pe_vals, zen_names, pe_names)
    keys = zen_vals.map do |pair, row|
      pe_row = pe_vals[pair]
      fail "pe entry for t = #{pair[0]} p = #{pair[1]} not found" unless pe_row
      [pair[0].to_f, pair[1].to_f]
    end

    @zen_vals = zen_vals
    
    vars = @@properties.map do |p|
      get_property p, zen_vals, pe_vals, zen_names, pe_names
    end
    values = vars.transpose.map { |v| v.inject :+ }
    @@properties.each_with_index { |p, i| self.class.define_components p, 3*i }
    keys.zip(values).to_h
  end

  def initialize(zen_name, pe_name)
    zen_rows = CSV.read(zen_name, headers: true)
    pe_rows = CSV.read(pe_name, headers: true)

    zen_headers = zen_rows.headers
    @zen_units = zen_headers.map { |h| l = h.split; [l[0], l[1]] }.to_h
    @zen_names = zen_headers.map { |h| [h.split[0], h] }.to_h

    pe_headers = pe_rows.headers
    @pe_units = pe_headers.map { |h| l = h.split; [l[0], l[1]] }.to_h
    pe_names = pe_headers.map { |h| [h.split[0], h] }.to_h

    @table = build_tables(map_values(zen_rows, @zen_names),
                          map_values(pe_rows, pe_names), @zen_names, pe_names)
  end
end

options = {}
options_parser = OptionParser.new do |opts|

  opts.on('-z ZENCSV', '--zen ZENCSV', 'csv file by zen') do |property_name|
    options[:zen_name] = property_name
  end

  opts.on('-p PCSV', '--pe PCSV',
          'csv file by Petroleum Experts') do |property_name|
    options[:pe_name] = property_name
  end

  opts.on('-T TEMP', '--temp TEMP', 'temperature value') do |temp|
    options[:temp] = temp
  end

  opts.on('-P PRESSURE', '--pressure PRESSURE', 'pressure value') do |pressure|
    options[:pressure] = pressure
  end

  opts.on('-G PROPERTY', '--get PROPERTY', 'Property name') do |property|
    options[:property] = property
  end

  opts.on('-Z', '--ZEN', 'Zen Property name') do |property|
    options[:zen_property] = true
  end

  opts.on('-R x', '--R x', 'generate R code for -G property and x') do |x|
    options[:R] = x
  end

  opts.on('-% PERCENTAGE', '--percentage PERCENTAGE',
          'error percentage') do |per|
    options[:per] = per
  end
end

options_parser.parse!

zen_name = options[:zen_name]
fail 'zen csv file not given' unless zen_name

pe_name = options[:pe_name]
fail 'pe csv file not given' unless pe_name
  
data = Table.new(zen_name, pe_name)

t = options[:temp]
p = options[:pressure]
property = options[:property]
property.downcase! if property

r = options[:R]
if r
  fail 'R option must be p or t' if r != 'p' && r != 't'
  fail 'R option without -G property' unless property
  fail "invalid property #{property}" unless data.check_property property
  if r == 'p'
    values = data.pressures(property)
    values.each do |v|
      puts "#{v}"
    end
    exit
  end
  if r == 't'
    fail "-R t Not yet implemented"
    exit
  end

end

missing = (t && !p) || (!t && p)
value_requested = t && p && property

fail 'option -T temp and -P pressure must be used together' if missing

if value_requested
  mtd_name = property + '_s'
  fail "invalid property #{property}" unless data.respond_to? mtd_name
  puts data.send mtd_name, t, p
  exit
end

per = options[:per].to_f if options[:per]
if per
  fail "Property has not been specified" unless property
  fail "% must between 1 and 99" if per < 0.01 || per > 99
  mtd_name = property + '_subset'
  fail "invalid property #{property}" unless data.respond_to? mtd_name
  data.send(mtd_name, per).each { |e| puts e }
  exit
end

zen_property = options[:zen_property]

if t && p
  if zen_property
    data.get_zen_entry t, p
    exit
  elsif
    lines = data.entry_s(t, p)
  end
else
  lines = data.format
end

fail "Property request (option -G) without t and p parameters" if property

lines.each do |l|
  print "#{l[0]} #{l[1]} "
  l.drop(2).each_slice(3) do |s|
    print "#{s[0]} #{s[1]} #{s[2]}"
    print ' ' if s != l.last
  end
  puts
end
