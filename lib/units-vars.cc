# include <mutex>

# include <ah-stl-utils.H>

# include <units/pvt-units.H>

# include <json.hpp>

using json = nlohmann::json;

// the following data is declared in units.H
UnitItemTable PhysicalQuantity::tbl;

UnitItemTable Unit::tbl;
DynSetTree<const Unit * const> Unit::unit_tbl;

UnitHashTbl __unit_name_name_tbl;
UnitHashTbl __unit_name_symbol_tbl;
UnitHashTbl __unit_symbol_name_tbl;
UnitHashTbl __unit_symbol_symbol_tbl;
CompoundUnitTbl __compound_unit_tbl;

static std::mutex unit_mutex;

const PhysicalQuantity
PhysicalQuantity::null_physical_quantity("NullPhysicalQuantity", "NullPQ",
					 "Null Physical Quantity");

const Unit Unit::null_unit("NullUnit", "Null Unit", "Null unit",
			   PhysicalQuantity::null_physical_quantity,
			   0.0, 1.0, 0.1);

bool conversion_exist(const char * src_symbol, const char * tgt_symbol)
{
  std::lock_guard<std::mutex> critical_section(unit_mutex);
  return exist_conversion(src_symbol, tgt_symbol);
}

double unit_convert(const char * src_symbol, const char * tgt_symbol,
		    double val)
{
  std::lock_guard<std::mutex> critical_section(unit_mutex);
  return unit_convert_symbol_to_symbol(src_symbol, val, tgt_symbol);
}

static json to_json(const Unit * unit_ptr)
{
  json j;
  j["name"] = unit_ptr->name;
  j["description"] = unit_ptr->description;
  j["symbol"] = unit_ptr->symbol;
  j["minimum value"] = unit_ptr->min_val;
  j["maximum value"] = unit_ptr->max_val;
  j["epsilon"] = unit_ptr->get_epsilon();
  return j;
}

static json to_json(const PhysicalQuantity * const pq)
{
  json j;
  j["name"] = pq->name;
  j["description"] = pq->description;
  j["symbol"] = pq->symbol;
  j["units"] =
    to_vector(pq->units().maps<json>([] (auto p) { return to_json(p); }));
  
  return j;
}

string units_json()
{
  json j;
  j["Zen physical quantities"] =
    to_vector(PhysicalQuantity::quantities().maps<json>([] (auto p)
    { return to_json(p); }));
  return j.dump(2);
}

// The following global singleton variables are generated by extract-cv script
